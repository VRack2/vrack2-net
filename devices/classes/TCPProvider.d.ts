/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import * as net from 'net';
/**
 * TCPProvider — класс для управления устойчивым TCP-соединением с поддержкой автоматического
 * переподключения, таймаутов, метрик и буферизации входящих данных.
 *
 * Предназначен для сценариев, где требуется надёжный обмен бинарными пакетами по TCP
 * (например, промышленные протоколы, Modbus TCP и т.п.).
 */
declare class TCPProvider {
    /**
     * Экземпляр TCP-сокета из модуля 'net'. Может быть null до инициализации или после уничтожения.
     */
    private socket;
    /**
     * Буфер накопленных, но ещё не обработанных входящих данных.
     * Сбрасывается перед каждым новым запросом.
     */
    private buffer;
    /**
     * Таймер, отслеживающий таймаут на уровне отдельного запроса.
     * Очищается при получении ответа или при уничтожении провайдера.
     */
    private timeoutTimer;
    /**
     * Колбэки для разрешения/отклонения промиса текущего запроса.
     * Устанавливаются в методе request(), сбрасываются после завершения запроса.
     */
    private resolve;
    private reject;
    /**
     * Колбэки жизненного цикла соединения:
     * - readyCallback вызывается при успешном подключении;
     * - destroyCallback — при закрытии сокета;
     * - packageCheckCallback — для определения завершённости пакета.
     */
    private readyCallback;
    private destroyCallback;
    private packageCheckCallback;
    /**
     * Функция обратного вызова для отправки метрик (событий, ошибок, времени выполнения и т.д.).
     * Принимает имя метрики и её значение.
     */
    private metricCallback;
    private eventCallback;
    /**
     * Параметры подключения (хост, порт, таймаут и т.д.), передаваемые в net.Socket.connect().
     */
    private options;
    /**
     * Вызывает тайм-аут сокета через `timeout` миллисекунд бездействия
    */
    private timeout;
    /**
     * Очередь устройств для срочной передачи управления
     *
     * Когда какое то устройство, которое не имеет сейчас контроля над TCPProvider
     * но очень срочно хочет его получить - оно может добавить себя в срочную очередь
     *
     * @see addUrgentQueue
    */
    private urgentQueue;
    /**
     * Объект состояния провайдера. Содержит флаги и счётчики для отслеживания
     * активности соединения и выполнения запросов.
     */
    state: {
        counter: number;
        timeout: boolean;
        connected: boolean;
        progress: boolean;
        connection: boolean;
        errors: number;
        byteSend: number;
        byteReceive: number;
        device: string;
        deviceType: string;
        urgentQueue: string[];
    };
    /**
     * Конструктор инициализирует параметры подключения и колбэк метрик,
     * после чего немедленно создаёт и пытается установить TCP-соединение.
     *
     * @param options — параметры подключения (хост, порт, локальный адрес и т.д.)
     * @param mCb — функция для логирования или сбора метрик
     */
    constructor(options: net.TcpSocketConnectOpts, timeout: number | undefined, mCb: (event: string, data: any) => void, // Metric CB
    eCb: (event: string, data: any) => void, // Error CB
    rCb?: () => void, // Ready CB
    dCb?: () => void);
    /**
     * Возвращает текущее содержимое буфера входящих данных.
     * Используется внешним кодом (например, парсером протокола) для извлечения ответа.
     */
    getBuffer(): Buffer;
    /**
     * Добавление в срочную очередь устройства
    */
    addUrgentQueue(device: string): void;
    /**
     * Устанавливает текущее активное устройство
     * (устройство которое занимает TCPProvider)
    */
    setDevice(type: string, device: string): void;
    /**
     * Очищаем информацию о активном устройстве
    */
    clearDevice(): void;
    /**
     * Проверяет флаги и соответсвие срочной очереди.
     * Возвращает true если все условия для запроса учтены и их можно делать
     *
     * Если же возвращает false - **устройство должно немедленно передать управления дальше**
     *
     * Так же проверяет срочную очередь - если есть несоответсвие текущего устройства и устройства
     * в очереди - возвращает false.
    */
    canRequest(): boolean;
    /**
     * Устанавливает пользовательскую функцию для определения завершённости пакета.
     * Функция принимает текущий буфер и должна вернуть true, если пакет полный.
     */
    setPkgCheck(callback: (buffer: Buffer) => boolean): void;
    /**
     * Выполняет запрос с автоматическими повторами в случае таймаута.
     *
     * @param buffer — данные для отправки
     * @param timeout — таймаут одного запроса (в миллисекундах)
     * @param maxRetries — максимальное количество попыток (по умолчанию 3)
     * @returns Promise<boolean> — разрешается при успешном получении полного пакета
     * @throws Error — если все попытки завершились неудачей
     */
    autoRequest(buffer: Buffer, timeout: number, maxRetries?: number): Promise<boolean>;
    /**
     * Выполняет одиночный запрос: отправляет данные и ожидает полный ответ.
     *
     * Перед отправкой проверяет, что соединение установлено и провайдер не занят.
     * Подписывается на данные один раз, используя once, и запускает таймер таймаута.
     *
     * @param buffer — данные для отправки
     * @param timeout — таймаут запроса в миллисекундах
     * @returns Promise<boolean> — разрешается при получении полного пакета
     */
    request(buffer: Buffer, timeout: number): Promise<boolean>;
    /**
     * Принудительно закрывает соединение и освобождает все ресурсы:
     * - очищает таймер запроса;
     * - удаляет обработчики событий сокета;
     * - уничтожает сокет;
     * - отклоняет текущий промис запроса (если есть).
     */
    destroy(): void;
    /**
     * Создаёт новый экземпляр net.Socket, применяет таймаут соединения
     * и регистрирует обработчики событий сокета.
     * Затем инициирует подключение к удалённому хосту.
     */
    private createSocket;
    /**
     * Обработчик события 'connect'.
     * Сбрасывает флаги таймаута и подключения, устанавливает флаг успешного соединения,
     * отправляет метрику и вызывает колбэк готовности.
     */
    private handleConnect;
    /**
     * Обработчик события 'timeout' сокета.
     * Устанавливает флаг таймаута, принудительно закрывает сокет с ошибкой
     * и через 1 секунду пытается пересоздать соединение.
     */
    private handleTimeout;
    /**
     * Обработчик события 'close'.
     * Вызывает колбэк уничтожения, сбрасывает флаги соединения,
     * отправляет метрику отключения и, если закрытие не вызвано таймаутом,
     * пытается переподключиться через 3 секунды.
     */
    private handleClose;
    /**
     * Обработчик входящих данных. Вызывается один раз на каждую порцию данных
     * благодаря использованию socket.once('data', ...).
     *
     * Накапливает данные в буфере, отправляет метрику чтения и проверяет,
     * достаточно ли данных для формирования полного пакета.
     * Если пакет неполный — повторно подписывается на следующую порцию.
     *
     * @param data — буфер с новыми входящими данными
     */
    private handleData;
    /**
     * Завершает текущий запрос: очищает таймер таймаута, сбрасывает флаг выполнения,
     * увеличивает счётчик успешных запросов и разрешает промис.
     */
    private completeRequest;
}
export default TCPProvider;
